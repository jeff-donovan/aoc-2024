0,3,5,4,3,0

working backwards...

1. need to end somehow, which means...
    _instruction_pointer >= len(inputs) - 1
    _instruction_pointer >= 6 - 1
    _instruction_pointer >= 5

2. output index 5 was 0, which means `out` was run:
    0 = combo_operand % 8
    - so the value of combo_operand must have been 0
        - either self._operand was 0 or...
        - self._operand was 4 AND self.register_a was a multiple of 8
        - self._operand was 5 AND self.register_b was a multiple of 8
            - MIGHT NOT HAVE BEEN POSSIBLE
        - self._operand was 6 AND self.register_c was a multiple of 8
            - DEFINITELY NOT POSSIBLE

    - if self._operand was 0, self._instruction_pointer must have been 4 (aka value of 3 in the inputs list)
    - if self._operand was 4, self._instruction_pointer must have been 2 (aka value of 5)
    - if self._operand was 5 (maybe not possible?), self._instruction_pointer

3. let's consider case 1: self._operand was 0, self._instruction_pointer was 4
    - could we have jumped to self._instruction_pointer of 4? YES! there is a 4 in the inputs list at index 3
        in that scenario, current A must have been greater than 0
    - IF we didn't jump, we had to come from 2 before
        self._instruction_pointer = 2
        self._operand = 5

^^^ SOMETHING LIKE THIS, ALTHOUGH IT IS LATE AND I AM PROBABLY WRONG ON EXACT STUFF

HOW TO SOLVE?!
    * THE SOLUTION IS LIKELY TO FAN OUT ALL POSSIBLE COMBOS STARTING FROM THE END
    * THEN WHATEVER THE MINIMUM A VALUE IS, THATS THE SOLUTION
    * WILL WANT TO run the "is_copy()" helper to confirm
    * THIS FEELS LIKE DEPTH FIRST SEARCH AGAIN
